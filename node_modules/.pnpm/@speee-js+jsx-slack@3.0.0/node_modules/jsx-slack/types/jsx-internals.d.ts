import type { JSXSlack } from './jsx';
export interface BuiltInComponent<P extends {}> extends JSXSlack.FC<P> {
    readonly $$jsxslackComponent: {
        name: string;
    } & Record<any, any>;
}
export declare const createElementInternal: <P extends {} = {}>(type: JSXSlack.FC<P> | keyof JSXSlack.JSX.IntrinsicElements, props?: P | null, ...children: JSXSlack.ChildElement[]) => JSXSlack.JSX.Element | null;
/**
 * Create the component for JSON payload building with jsx-slack.
 *
 * The passed functional component has to return JSON object or `null`, to build
 * JSON payload for Slack. Unlike a simple functional component defined by
 * JavaScript function, the output would be always preserved in JSON even if it
 * was an array.
 *
 * @remarks
 * `createComponent()` is an internal helper to create built-in components for
 * jsx-slack. Typically user must use a simple function definition of JavaScript
 * to create the functional component.
 *
 * @param name - Component name for showing in debug log
 * @param component - The functional component to turn into jsx-slack component
 * @param meta - An optional metadata for jsx-slack component
 * @return A created jsx-slack component
 */
export declare const createComponent: <P extends {}, O extends object>(name: string, component: (props: P) => O | null, meta?: Record<any, any>) => BuiltInComponent<P>;
export declare const FragmentInternal: BuiltInComponent<{
    children: JSXSlack.ChildElements;
}>;
/**
 * Verify the passed function is a jsx-slack component.
 *
 * @param fn - A function to verify
 * @return `true` if the passed object was a jsx-slack component, otherwise
 *   `false`.
 */
export declare const isValidComponent: <T extends {} = any>(fn: unknown) => fn is BuiltInComponent<T>;
export declare const isValidElementInternal: (obj: unknown) => obj is JSXSlack.JSX.Element;
/**
 * Verify the passed object is a jsx-slack element created from built-in
 * component.
 *
 * @param element - An object to verify
 * @param component - The optional component to match while verifying
 * @return `true` if the passed object was a jsx-slack element created from
 *   built-in component, otherwise `false`
 */
export declare const isValidElementFromComponent: (obj: unknown, component?: JSXSlack.FunctionComponent<any>) => obj is JSXSlack.JSX.Element;
/**
 * Clean up hidden meta value for jsx-slack from object.
 *
 * If the built-in component has nested JSX output such as alias, a hidden
 * metadata can reference an internal JSX from the public partial object. An
 * internal would not matter for jsx-slack user, so the error message displaying
 * private JSX info may confuse.
 *
 * It just re-assigns public objects into new object, but this helper makes
 * clear its purpose.
 *
 * @param element - The object with meta value for jsx-slack
 * @return The object without meta value
 */
export declare const cleanMeta: <T extends object>(element: T) => T extends (infer R)[] ? R[] : Omit<T, "$$jsxslack">;
